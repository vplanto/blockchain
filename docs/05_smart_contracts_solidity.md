# Лекція 5. Смарт-контракти та Solidity: читати код і розуміти концепти

**Мета:** Навчитися читати Solidity-код і розуміти основні концепти: стан, виклики, газ, перевірки, патерни безпеки.

Практичні приклади взято з папки [solidity](../solidity/) цього репозиторію і розраховані на роботу в [Remix IDE](https://remix.ethereum.org/) (онлайн, без встановлення).

---

## Питання для обговорення

1. Що таке "контракт" у блокчейні: хто його виконує і хто платить за виконання?
2. Чому в коді контракту не можна просто викликати "зачекати 1 годину" або "запитати API погоди"?
3. Як контракт "пам’ятає" дані між викликами?

---

## 1. Де живуть приклади і як їх відкрити

- **Код:** папка [solidity](../solidity/) у цьому репозиторії. Файли: `HelloWorld_v1.sol`, `HelloWorld_v2_SelfDestruct.sol`, `Voter_v1.sol` … `Voter_v4_VoteByString.sol`.
- **Середовище:** [Remix IDE](https://remix.ethereum.org/). Відкрийте файл (File → Open, або вставте код), виберіть компілятор (наприклад, 0.8.x), зберіть (Compile), запустіть на віртуальній ноді (Deploy у вкладці Deploy & run transactions).

---

## 2. HelloWorld: стан і виклики

Приклад: `HelloWorld_v1.sol`.

```solidity
contract HelloWorld {
    uint private value;

    function setValue(uint newValue) public {
        value = newValue;
    }

    function getValue() public view returns (uint) {
        return value;
    }
}
```

Що тут важливо: контракт має **стан** — змінну `value`, що зберігається в storage. `setValue` змінює стан (коштує газ); `getValue` лише читає (view, не змінює стан, виклик без плати ззовні). Кожен виклик функції — це транзакція (або внутрішній виклик з іншої транзакції). Контракт не "крутиться" сам по собі, він реагує лише на виклики.

---

## 3. Selfdestruct і незворотність

Приклад: `HelloWorld_v2_SelfDestruct.sol` — додано функцію `remove()`, яка викликає `selfdestruct(payable(address(0)))`. Після виконання контракт перестає існувати, а залишок ETH (якщо був) відправляється на вказану адресу. Це незворотна операція: на ланцюгу її не відкотити.

---

## 4. Voter: конструктор, масиви, перевірки

Приклад: `Voter_v1.sol`.

- **constructor(string[] memory _options):** викликається один раз при деплої. Ініціалізує список варіантів і масив голосів.
- **vote(uint option):** збільшує лічильник для обраного варіанту. `require(0 <= option && option < options.length, "Invalid option")` — перевірка введення; при невиконанні транзакція відкочується (revert).
- **getOptions / getVotes:** читання даних (view).

Концепти: контракт як "об’єкт" зі станом; перевірки через `require`; газ за запис (votes[option] += 1) платить той, хто викликає `vote`.

---

## 5. Один голос на адресу: mapping

Приклад: `Voter_v2_OneVoteOnly.sol`.

- `mapping(address => bool) hasVoted` — для кожної адреси зберігаємо, чи вже голосувала.
- У `vote`: `require(!hasVoted[msg.sender], "Already voted")`; після перевірки викликається `recordVote(option)`, де встановлюється `hasVoted[msg.sender] = true` і оновлюється масив голосів.

Концепти: `msg.sender` — адреса, що викликала функцію; mapping для "один голос на адресу"; порядок: спочатку перевірки, потім зміна стану (підхід Checks-Effects-Interactions).

---

## 6. Голосування за рядком і вартість газу

У `Voter_v3_StringOptions.sol` є перевантаження `vote(string memory option)`: порівняння рядків через `keccak256(bytes(a)) == keccak256(bytes(b))`, цикл по всіх options. Це дорожче за газ, ніж голосування за індексом (uint). У `Voter_v4_VoteByString.sol` використовується `mapping(string => OptionPos) posOfOption`, заповнений у конструкторі: пошук за рядком стає O(1) замість циклу — приклад оптимізації газу через структуру даних.

---

## 7. Безпека: Reentrancy і Checks-Effects-Interactions

У лекції та в Case Studies (The DAO) згадано: небезпечно спочатку відправляти кошти зовні (external call), а потім оновлювати внутрішній стан. Контракт одержувача може у callback знову викликати вашу функцію і "повторити" вхід (reentrancy). Патерн: спочатку перевірки (checks), потім зміна стану (effects), в кінці — зовнішні виклики (interactions). Плюс використання модифікаторів на кшталт `nonReentrant` (наприклад, OpenZeppelin).

---

## 8. Що студент повинен вміти після лекції

- Відкрити приклад у Remix, скомпілювати, задеплоїти на віртуальній ноді.
- Пояснити: де стан (storage), хто платить газ, навіщо `require` і що таке revert.
- Розрізняти: view/pure (читання) і функції, що змінюють стан.
- Пояснити різницю між Voter_v1 (без обмеження голосів) і Voter_v2 (один голос на адресу); між v3 (пошук по рядку циклом) і v4 (mapping для O(1)).
- Знати про selfdestruct і про патерн Checks-Effects-Interactions у контексті reentrancy.

---

## Питання та відповіді (екзаменаційний блок)

**П1.** Хто платить за виконання функції смарт-контракту і як це пов’язано з газом?

**В1.** За виконання платить той, хто ініціював транзакцію (викликав функцію): він задає gas limit і gas price. Витрачений газ списується з його рахунку. Якщо газу не вистачило, виконання відкочується (revert), а вже витрачений газ не повертається.

---

**П2.** Навіщо в Solidity використовують `require`? Що відбувається, якщо умова не виконується?

**В2.** `require(умова, "повідомлення")` перевіряє умову перед подальшим виконанням. Якщо умова false, поточна транзакція негайно переривається (revert): зміни стану скасовуються, повідомлення може бути повернене викликачу. Це захист від невалідних вводів і порушення інваріантів контракту.

---

**П3.** Що таке `msg.sender` і як його використовують для "один голос на адресу"?

**В3.** `msg.sender` — адреса (акаунт або контракт), яка безпосередньо викликала поточну функцію. Для обмеження "один голос на адресу" зберігають mapping (наприклад, `mapping(address => bool) hasVoted`) і перед зарахуванням голосу перевіряють `require(!hasVoted[msg.sender])`, після чого встановлюють `hasVoted[msg.sender] = true`.

---

**П4.** У чому різниця між функціями view/pure і функціями, що змінюють стан?

**В4.** `view`: функція лише читає стан, не змінює його; виклик ззовні не потребує транзакції (не сплачується газ). `pure`: не читає і не змінює стан, лише обчислення. Функції без view/pure можуть змінювати storage; їх виклик — це транзакція, що сплачується газом.

---

**П5.** Що таке reentrancy і який патерн захищає від нього?

**В5.** Reentrancy — випадок, коли під час виконання вашого контракту ви робите зовнішній виклик (наприклад, переказ ETH), а контракт-одержувач у callback знову викликає вашу функцію. Якщо стан оновлено після переказу, він може ще мати "старі" значення, і атакуючий може повторно отримати кошти. Захист: патерн Checks-Effects-Interactions — спочатку оновити внутрішній стан, потім робити зовнішні виклики; можна використовувати модифікатори типу nonReentrant.
