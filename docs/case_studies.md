# Engineering Case Studies: Хроніки Розподілених Відмов

**Мета:** Аналіз реальних інцидентів у розподілених системах. Вчимося на чужих помилках, щоб не робити свої.
**Статус:** Живий документ. Оновлюється при нових інцидентах.

---

## Case #001: Ethereum Pectra Update & The "Empty Block" Attack
**Дата:** Березень 2025
**Компоненти:** Geth (Go Ethereum), EIP-6110, ERC-20 Standard
**Тип вразливості:** Logic Error / Edge Case Abuse

### 1. Контекст Інциденту
Команда Ethereum готувала масштабне оновлення **Pectra**. Ключова зміна — **EIP-6110**, яка мала спростити механізм депозитів для валідаторів, обробляючи їх безпосередньо в клієнтському шарі (Execution Layer). Оновлення було розгорнуто в тестовій мережі Sepolia.

### 2. Симптоми
* Вузли почали масово відхиляти валідні транзакції.
* Мережу заполонили **пусті блоки** (Empty Blocks).
* Прогрес фіналізації ланцюга зупинився.

### 3. Root Cause Analysis (Глибинна причина)
Проблема виникла на стику нового протоколу (EIP-6110) та старого стандарту (ERC-20).

1.  **Очікування розробників:** Контракт депозиту (Deposit Contract) буде отримувати лише валідні депозити (ETH).
2.  **Реальність (Стандарт):** Стандарт токенів ERC-20 дозволяє транзакцію `transfer(0)` — переказ нульової суми. Це абсолютно легальна операція.
3.  **Вектор атаки:** Невідомий хакер почав спамити Deposit Contract транзакціями з **нульовою сумою**.
4.  **Баг у Geth:** Логіка обробки EIP-6110 у клієнті Geth не була готова до "пустих" подій. Замість того щоб ігнорувати їх, вузол намагався їх обробити як помилкові депозити, що призводило до краху логіки формування блоку. Вузли, щоб не впасти, почали генерувати пусті блоки, ігноруючи мемпул.

> **Інженерний висновок:** Це класична помилка **Input Validation**. Розробники протестували "Happy Path" (депозит ETH) і "Error Path" (невалідний депозит), але пропустили "Valid but Useless Path" (нульовий переказ), який дозволений стандартом.

### 4. Рішення (Mitigation)
Команда розгорнула екстрений **"Private Patch"** для 10% критичних вузлів (Bootnodes). Патч примусово змушував клієнт ігнорувати логи транзакцій із нульовою сумою на адресу депозитного контракту.

### 5. Key Takeaway (Урок для студента)
У розподілених системах **стандарт — це закон**. Якщо стандарт ERC-20 дозволяє `transfer(0)`, ваша система *зобов'язана* це обробляти, навіть якщо це не має сенсу для бізнес-логіки.

---

## Case #002: The DAO Hack (2016)
**Дата:** Червень 2016
**Компоненти:** Ethereum Mainnet, Solidity Smart Contract
**Тип вразливості:** Reentrancy Attack (Race Condition)

### 1. Контекст Інциденту
Проект "The DAO" був першою спробою створити децентралізований венчурний фонд. Він зібрав ~$150 млн (14% всього ETH на той момент). Інвестори могли голосувати за проекти своїми токенами і виходити з фонду через функцію `splitDAO`.

### 2. Симптоми
* З балансу смарт-контракту почали зникати мільйони ETH.
* Транзакції виглядали легітимними з точки зору коду (функція `withdraw` викликалася власником токенів).
* Атака тривала годинами, але ніхто не міг її зупинити через незмінність (Immutability) блокчейну.

### 3. Root Cause Analysis (Глибинна причина)
Помилка була у порядку виконання операцій. Розробники порушили патерн **Checks-Effects-Interactions**.

**Вразливий код (Спрощено):**
```solidity
function withdraw(uint amount) {
    if (credit[msg.sender] >= amount) {
        // 1. INTERACTION: Спочатку відправляємо гроші (зовнішній виклик)
        // Це передає керування отримувачу!
        msg.sender.call.value(amount)(); 
        
        // 2. EFFECTS: Тільки ПОТІМ оновлюємо баланс
        // Цей рядок ніколи не виконувався вчасно
        credit[msg.sender] -= amount; 
    }
}
```

**Механіка атаки:**

1. Хакер створює шкідливий контракт.
2. Хакер викликає `withdraw()`.
3. DAO відправляє ETH на контракт хакера.
4. Контракт хакера має спеціальну `fallback function`, яка автоматично спрацьовує при отриманні ETH. Ця функція **знову викликає `withdraw()**` у DAO.
5. Оскільки рядок `credit -= amount` ще не виконався, DAO "думає", що у хакера все ще повний баланс, і відправляє гроші знову.
6. Цикл повторюється рекурсивно до вичерпання газу або балансу DAO.

### 4. Рішення (Mitigation)

Технічно код зупинити не вдалося. Спільнота Ethereum прийняла політичне рішення:

* **Hard Fork:** Змінити історію блокчейну, "відкотивши" транзакції хакера на певний блок.
* Це створило ідеологічний розкол:
* **Ethereum Classic (ETC):** Ті, хто вважав, що "Код є Закон" (Code is Law) і втручання неприпустиме.
* **Ethereum (ETH):** Ті, хто вибрав порятунок коштів (Social Consensus).

### 5. Key Takeaway

1. **Checks-Effects-Interactions:** Завжди спочатку оновлюйте внутрішній стан (баланси), і тільки в самому кінці робіть зовнішні виклики.
2. **Mutex:** Використовуйте модифікатори типу `nonReentrant` (OpenZeppelin), які блокують повторний вхід у функцію, поки вона не завершилась.

---

## Case #003: The "Sleeping Approval" Drain ($340k)
**Дата:** Грудень 2025
**Компоненти:** ERC-20 Standard (Approve/TransferFrom), Web3 Wallet
**Тип вразливості:** Phishing / Operational Security Failure

### 1. Контекст Інциденту
Користувач переказав на свій старий гаманець 340,000 USDC. Буквально за секунди всі кошти були виведені на адресу зловмисника. Жодних дій (підписання транзакцій) у цей момент власник не вчиняв.

### 2. Симптоми
* Миттєве зникнення коштів після поповнення рахунку.
* В історії транзакцій видно виклик функції `transferFrom`, ініційований сторонньою адресою, а не власником.
* Слідів компрометації приватного ключа (Seed phrase) не виявлено.

### 3. Root Cause Analysis (Глибинна причина)
Причина — **"Unlimited Approval"**, підписаний 5 років тому (у 2020 році).

1.  **Механіка ERC-20:** Щоб смарт-контракт (наприклад, DEX) міг забрати ваші токени для обміну, ви мусите спочатку викликати функцію `approve(spender, amount)`.
2.  **UX Pattern:** Більшість DApps (для економії газу) просять дозвіл на `2^256 - 1` (Infinite Approval). Це означає "бери скільки хочеш, будь-коли".
3.  **Пастка:** У 2020 році користувач взаємодіяв із фішинговим сайтом і дав такий дозвіл шахрайському контракту.
4.  **Сплячий режим:** Хакер не чіпав гаманець, поки там було порожньо. Його бот моніторив ланцюжок 24/7. Як тільки з'явилися гроші — спрацював тригер `transferFrom`.

> **Інженерний висновок:** Це не баг коду, це **Design Flaw** стандарту ERC-20. Він розділяє "право володіння" і "право витрачання", але інтерфейси гаманців погано візуалізують ризики "висячих" дозволів.

### 4. Рішення (Mitigation)
* **Для користувача:** Регулярна "гігієна". Використання інструментів типу **Revoke.cash** або вбудованих функцій Etherscan для скасування старих дозволів.
* **Для розробника:** Використання **Permit (EIP-2612)**. Це дозволяє підписувати дозволи офф-чейн (без газу) і лише на конкретну транзакцію, що зменшує вікно можливостей для атаки.
* **Wallet Security:** Сучасні гаманці (Rabby, Phantom) тепер попереджають про підписання дозволів для підозрілих або нових контрактів.

### 5. Key Takeaway (Урок для студента)
`approve()` — це найнебезпечніша функція в DeFi.
Якщо ви будуєте протокол, уникайте запиту Infinite Approval, якщо це не критично необхідно. Якщо ви користувач — вважайте, що кожен підписаний `approve` — це відкриті двері до вашого сейфу, про які ви забудете завтра.
