# Engineering Case Studies: Хроніки Розподілених Відмов

**Мета:** Аналіз реальних інцидентів у розподілених системах. Вчимося на чужих помилках, щоб не робити свої.
**Статус:** Живий документ. Оновлюється при нових інцидентах.

---

## Case #001: Ethereum Pectra Update & The "Empty Block" Attack
**Дата:** Березень 2025
**Компоненти:** Geth (Go Ethereum), EIP-6110, ERC-20 Standard
**Тип вразливості:** Logic Error / Edge Case Abuse

### 1. Контекст Інциденту
Команда Ethereum готувала масштабне оновлення **Pectra**. Ключова зміна — **EIP-6110**, яка мала спростити механізм депозитів для валідаторів, обробляючи їх безпосередньо в клієнтському шарі (Execution Layer). Оновлення було розгорнуто в тестовій мережі Sepolia.

### 2. Симптоми
* Вузли почали масово відхиляти валідні транзакції.
* Мережу заполонили **пусті блоки** (Empty Blocks).
* Прогрес фіналізації ланцюга зупинився.

### 3. Root Cause Analysis (Глибинна причина)
Проблема виникла на стику нового протоколу (EIP-6110) та старого стандарту (ERC-20).

1.  **Очікування розробників:** Контракт депозиту (Deposit Contract) буде отримувати лише валідні депозити (ETH).
2.  **Реальність (Стандарт):** Стандарт токенів ERC-20 дозволяє транзакцію `transfer(0)` — переказ нульової суми. Це абсолютно легальна операція.
3.  **Вектор атаки:** Невідомий хакер почав спамити Deposit Contract транзакціями з **нульовою сумою**.
4.  **Баг у Geth:** Логіка обробки EIP-6110 у клієнті Geth не була готова до "пустих" подій. Замість того щоб ігнорувати їх, вузол намагався їх обробити як помилкові депозити, що призводило до краху логіки формування блоку. Вузли, щоб не впасти, почали генерувати пусті блоки, ігноруючи мемпул.

> **Інженерний висновок:** Це класична помилка **Input Validation**. Розробники протестували "Happy Path" (депозит ETH) і "Error Path" (невалідний депозит), але пропустили "Valid but Useless Path" (нульовий переказ), який дозволений стандартом.

### 4. Рішення (Mitigation)
Команда розгорнула екстрений **"Private Patch"** для 10% критичних вузлів (Bootnodes). Патч примусово змушував клієнт ігнорувати логи транзакцій із нульовою сумою на адресу депозитного контракту.

### 5. Key Takeaway (Урок для студента)
У розподілених системах **стандарт — це закон**. Якщо стандарт ERC-20 дозволяє `transfer(0)`, ваша система *зобов'язана* це обробляти, навіть якщо це не має сенсу для бізнес-логіки.

---

## Case #002: The DAO Hack (2016)
**Дата:** Червень 2016
**Компоненти:** Ethereum Mainnet, Solidity Smart Contract
**Тип вразливості:** Reentrancy Attack (Race Condition)

### 1. Контекст Інциденту
Проект "The DAO" був першою спробою створити децентралізований венчурний фонд. Він зібрав ~$150 млн (14% всього ETH на той момент). Інвестори могли голосувати за проекти своїми токенами і виходити з фонду через функцію `splitDAO`.

### 2. Симптоми
* З балансу смарт-контракту почали зникати мільйони ETH.
* Транзакції виглядали легітимними з точки зору коду (функція `withdraw` викликалася власником токенів).
* Атака тривала годинами, але ніхто не міг її зупинити через незмінність (Immutability) блокчейну.

### 3. Root Cause Analysis (Глибинна причина)
Помилка була у порядку виконання операцій. Розробники порушили патерн **Checks-Effects-Interactions**.

**Вразливий код (Спрощено):**
```solidity
function withdraw(uint amount) {
    if (credit[msg.sender] >= amount) {
        // 1. INTERACTION: Спочатку відправляємо гроші (зовнішній виклик)
        // Це передає керування отримувачу!
        msg.sender.call.value(amount)(); 
        
        // 2. EFFECTS: Тільки ПОТІМ оновлюємо баланс
        // Цей рядок ніколи не виконувався вчасно
        credit[msg.sender] -= amount; 
    }
}

```

**Механіка атаки:**

1. Хакер створює шкідливий контракт.
2. Хакер викликає `withdraw()`.
3. DAO відправляє ETH на контракт хакера.
4. Контракт хакера має спеціальну `fallback function`, яка автоматично спрацьовує при отриманні ETH. Ця функція **знову викликає `withdraw()**` у DAO.
5. Оскільки рядок `credit -= amount` ще не виконався, DAO "думає", що у хакера все ще повний баланс, і відправляє гроші знову.
6. Цикл повторюється рекурсивно до вичерпання газу або балансу DAO.

### 4. Рішення (Mitigation)

Технічно код зупинити не вдалося. Спільнота Ethereum прийняла політичне рішення:

* **Hard Fork:** Змінити історію блокчейну, "відкотивши" транзакції хакера на певний блок.
* Це створило ідеологічний розкол:
* **Ethereum Classic (ETC):** Ті, хто вважав, що "Код є Закон" (Code is Law) і втручання неприпустиме.
* **Ethereum (ETH):** Ті, хто вибрав порятунок коштів (Social Consensus).

### 5. Key Takeaway

1. **Checks-Effects-Interactions:** Завжди спочатку оновлюйте внутрішній стан (баланси), і тільки в самому кінці робіть зовнішні виклики.
2. **Mutex:** Використовуйте модифікатори типу `nonReentrant` (OpenZeppelin), які блокують повторний вхід у функцію, поки вона не завершилась.
