# Практикум p01. Безпека контрактів: reentrancy та патерн CEI

**Мета:** Розібрати на прикладах, чому порядок операцій у контракті важливий, і як захиститися від reentrancy. Матеріал опирається на [case_studies.md](../case_studies.md) (The DAO, EIP-6110).

---

## Питання для обговорення

1. Чи може функція контракту викликати інший контракт? Що відбувається з керуванням під час такого виклику?
2. Чому "спочатку переказати гроші, потім оновити баланс" — небезпечно?
3. Що таке "fallback" функція і коли вона викликається?

---

## 1. Повторення: The DAO (Case #002)

Прочитайте в [case_studies.md](../case_studies.md) розділ "Case #002: The DAO Hack". Зверніть увагу на вразливий порядок: спочатку `transfer` (зовнішній виклик), потім `credit[msg.sender] -= amount`. Атакуючий контракт у fallback знову викликає `withdraw` — і отримує гроші повторно, бо баланс ще не оновлено.

---

## 2. Патерн Checks-Effects-Interactions (CEI)

Рекомендований порядок у функції:

1. **Checks:** перевірки (`require`, перевірка балансів, прав).
2. **Effects:** зміна внутрішнього стану контракту (баланси, прапорці, лічильники).
3. **Interactions:** зовнішні виклики (transfer, виклик іншого контракту).

Якщо спочатку оновити стан, а вже потім робити transfer, повторний вхід (reentrancy) побачить уже оновлений баланс і не зможе отримати гроші вдруге.

---

## 3. Завдання на читання коду

У будь-якому контракті з переказом коштів (або з викликом зовнішнього контракту) знайдіть у коді (або на умовному прикладі):

- Де виконується зовнішній виклик (наприклад, `transfer`, `call`, `send`)?
- Де оновлюється внутрішній стан (mapping балансів, прапори)?
- Чи виконується оновлення стану до чи після зовнішнього виклику? Якщо після — це потенційна вразливість до reentrancy.

---

## 4. Додатковий захист: nonReentrant

У реальних проєктах використовують модифікатори (наприклад, OpenZeppelin `ReentrancyGuard`): прапорець "функція вже виконується" блокує повторний вхід. Розуміння CEI достатньо для курсу; про nonReentrant можна згадати як про додатковий шар захисту.

---

## Питання та відповіді (екзаменаційний блок)

**П1.** Що таке reentrancy і як атакуючий може його використати?

**В1.** Reentrancy — ситуація, коли під час виконання вашого контракту ви робите зовнішній виклик (наприклад, переказ ETH на інший контракт), а той у своїй fallback-функції знову викликає вашу функцію. Якщо внутрішній стан (наприклад, баланс "кредиту") оновлено після переказу, при повторному вході контракт ще "думає", що у викликача є баланс, і може переказати гроші знову. Так виникає дренінг коштів.

---

**П2.** Який порядок операцій у патерні Checks-Effects-Interactions і навіщо він потрібен?

**В2.** Спочатку перевірки (checks), потім зміна внутрішнього стану (effects), в кінці — зовнішні виклики (interactions). Потрібен для захисту від reentrancy: якщо стан оновлено до зовнішнього виклику, повторний вхід побачить уже зменшений баланс і не зможе отримати кошти повторно.

---

**П3.** Що таке fallback-функція в Solidity і коли вона викликається?

**В3.** Fallback — функція без імені (або `receive` для чистого надходження ETH), яка викликається, коли контракт отримує виклик без відповідності жодній іменованій функції, або коли на контракт надсилають ETH. Атакуючий може помістити в fallback повторний виклик вашого контракту — це основа reentrancy-атаки.
