# Практикум p00. Remix IDE та основи Solidity: читання коду

**Мета:** Отримати практичний досвід: відкрити приклади контрактів у Remix, скомпілювати, задеплоїти та перевірити поведінку. Уміння читати Solidity і бачити основні концепти в коді.

**Код прикладів:** папка [solidity](https://github.com/vplanto/blockchain/tree/main/solidity) у репозиторії курсу.  
**Середовище:** [Remix IDE](https://remix.ethereum.org/) (онлайн, без встановлення).

---

## Питання для обговорення

1. Що таке "деплой" контракту: хто його виконує і де він зберігається?
2. Чому після виклику `setValue(5)` значення залишається 5 при наступному виклику `getValue()`?
3. У файлі Voter — хто такий "той, хто викликає" функцію vote, і як контракт це знає?

---

## 1. Підготовка

1. Відкрийте [Remix IDE](https://remix.ethereum.org/).
2. Створіть файл у папці `contracts` (наприклад, `HelloWorld.sol`) або відкрийте файл з папки [solidity](https://github.com/vplanto/blockchain/tree/main/solidity) репозиторію курсу.
3. Вставте вміст [HelloWorld_v1.sol](https://github.com/vplanto/blockchain/blob/main/solidity/HelloWorld_v1.sol) (або скопіюйте код з лекції 5).

---

## 2. Завдання: HelloWorld

1. Вкладка **Compile**: виберіть компілятор (наприклад, 0.8.19), натисніть Compile.
2. Вкладка **Deploy & run transactions**: Environment — "Remix VM" (або один з варіантів). Deploy.
3. У панелі викликів викликайте `setValue` з аргументом, наприклад 42. Потім викликайте `getValue` і переконайтеся, що повертається 42.
4. Подумайте: хто "платить" газ у Remix VM при цих викликах? Чи змінюється баланс акаунта після setValue?

**Що перевірити в коді:** де оголошено стан (`uint private value`), яка функція його змінює, яка лише читає (view).

---

## 3. Завдання: Voter (v1 і v2)

1. Відкрийте в Remix контракт `Voter_v1.sol`. Подивіться на `constructor(string[] memory _options)`. В Remix при деплої можна передати масив рядків, наприклад `["A", "B", "C"]` (синтаксис залежить від інтерфейсу).
2. Після деплою викликайте `vote(0)`, `vote(1)`, `vote(0)` кілька разів. Перевірте `getVotes()`: чи збільшуються лічильники?
3. Відкрийте `Voter_v2_OneVoteOnly.sol`. Задеплойте з тими самими опціями. Спробуйте двічі викликати `vote(0)` з одного й того самого акаунта. Друга спроба має завершитися помилкою (revert). Чому?
4. У коді v2 знайдіть `mapping(address => bool) hasVoted` і `msg.sender`. Поясніть одним реченням, як реалізовано "один голос на адресу".

**Що перевірити в коді:** `require` для валідації опції та для заборони повторного голосування; приватна функція `recordVote` і де оновлюється стан.

---

## 4. Завдання: Voter v3 і v4 (рядки та газ)

1. У `Voter_v3_StringOptions.sol` є функція `vote(string memory option)`. Як вона знаходить індекс опції? Подивіться на цикл і порівняння через `keccak256(bytes(a))`.
2. У `Voter_v4_VoteByString.sol` той самий виклик `vote("A")` реалізований через `mapping(string => OptionPos) posOfOption`, заповнений у конструкторі. Чому це економніше за газ при великій кількості опцій?
3. У Remix після виклику функції перегляньте витрату газу (Gas used). Порівняйте (на рівні ідеї) виклик vote по індексу в v2 і vote по рядку в v3 при, наприклад, 10 опціях.

**Що перевірити в коді:** структура `OptionPos`, ініціалізація `posOfOption` у конструкторі; чому пошук за рядком у v4 — O(1).

---

## 5. Selfdestruct (обережно в тесті)

У `HelloWorld_v2_SelfDestruct.sol` є функція `remove()`, яка викликає `selfdestruct(payable(address(0)))`. У Remix VM задеплойте контракт, викликайте `remove()`. Після цього контракт не повинен відповідати на виклики. Це незворотна операція: у реальній мережі контракт зникає назавжди.

---

## Питання та відповіді (екзаменаційний блок)

**П1.** Як у Remix вибрати середовище виконання і що таке "Remix VM"?

**В1.** У вкладці "Deploy & run transactions" поле "Environment" дозволяє вибрати, де виконувати транзакції. "Remix VM" — це емуляція Ethereum у браузері без підключення до реальної мережі. Корисно для навчання: безкоштовно, миттєво, стан зберігається в сесії.

---

**П2.** У контракті Voter v2 яка роль `msg.sender` і mapping `hasVoted`?

**В2.** `msg.sender` — адреса того, хто безпосередньо викликав функцію (у Remix — обраний акаунт). `hasVoted[msg.sender]` зберігає, чи вже ця адреса голосувала. Перед зарахуванням голосу перевіряється `require(!hasVoted[msg.sender])`; після голосування встановлюється `hasVoted[msg.sender] = true`. Так реалізується обмеження "один голос на адресу".

---

**П3.** Чому в Voter v4 голосування за рядком дешевше за газ, ніж у v3?

**В3.** У v3 пошук опції за рядком робиться циклом по всьому масиву `options` і порівнянням хешів — це O(n) операцій і багато читання з пам’яті. У v4 у конструкторі заповнюється mapping "рядок → позиція"; при голосуванні за рядком достатньо одного звернення до mapping — O(1). Менше операцій — менше газу.

---

**П4.** Що відбувається після виклику `selfdestruct` у контракті?

**В4.** Контракт перестає існувати: його код і стан більше не доступні. Залишок ETH (якщо був) відправляється на вказану адресу. Операція незворотна. У наступних транзакціях виклики до цієї адреси не матимуть коду для виконання (або викликають fallback іншого контракту, якщо адресу перевикористано).
